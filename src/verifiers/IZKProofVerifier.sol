// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title IZKProofVerifier
 * @dev Interface for zero-knowledge proof verification in ZEPHIS Protocol
 * 
 * This interface defines the standard for verifying ZK-TLS proofs
 * generated by different proof systems (TLSN, MPCTLS, etc.)
 */
interface IZKProofVerifier {
    /**
     * @dev Enum defining supported proof types
     */
    enum ProofType {
        TLSN,           // TLS Notary proofs
        MPCTLS,         // Multi-Party Computation TLS proofs  
        CUSTOM          // Custom proof implementations
    }

    /**
     * @dev Struct representing a ZK proof submission
     */
    struct ProofData {
        bytes32 proofId;           // Unique identifier for the proof
        bytes32 sessionId;         // Session that generated the proof
        ProofType proofType;       // Type of proof system used
        bytes proof;               // The actual ZK proof data
        bytes32[] publicInputs;    // Public inputs to the circuit
        bytes32 commitment;        // Commitment to the proven data
        string circuitId;          // Identifier of the circuit used
        uint256 timestamp;         // When the proof was generated
        address submitter;         // Who submitted the proof
    }

    /**
     * @dev Struct for proof verification result
     */
    struct VerificationResult {
        bool isValid;              // Whether the proof is valid
        bytes32 proofHash;         // Hash of the verified proof
        uint256 verifiedAt;        // Timestamp of verification
        address verifier;          // Address that performed verification
        string reason;             // Reason for rejection if invalid
    }

    /**
     * @dev Emitted when a proof is submitted for verification
     */
    event ProofSubmitted(
        bytes32 indexed proofId,
        bytes32 indexed sessionId,
        ProofType indexed proofType,
        address submitter,
        bytes32 commitment
    );

    /**
     * @dev Emitted when a proof verification is completed
     */
    event ProofVerified(
        bytes32 indexed proofId,
        bool indexed isValid,
        address indexed verifier,
        bytes32 proofHash,
        string reason
    );

    /**
     * @dev Emitted when a proof is challenged
     */
    event ProofChallenged(
        bytes32 indexed proofId,
        address indexed challenger,
        string reason,
        uint256 challengeDeadline
    );

    /**
     * @dev Submit a ZK proof for verification
     * @param proofData The proof data to verify
     * @return proofId Unique identifier for the submitted proof
     */
    function submitProof(ProofData calldata proofData) external returns (bytes32 proofId);

    /**
     * @dev Verify a submitted ZK proof
     * @param proofId The ID of the proof to verify
     * @return result The verification result
     */
    function verifyProof(bytes32 proofId) external returns (VerificationResult memory result);

    /**
     * @dev Batch verify multiple proofs for efficiency
     * @param proofIds Array of proof IDs to verify
     * @return results Array of verification results
     */
    function batchVerifyProofs(bytes32[] calldata proofIds) 
        external 
        returns (VerificationResult[] memory results);

    /**
     * @dev Challenge a verified proof within the challenge period
     * @param proofId The ID of the proof to challenge
     * @param reason Reason for the challenge
     */
    function challengeProof(bytes32 proofId, string calldata reason) external;

    /**
     * @dev Get the verification result for a proof
     * @param proofId The ID of the proof
     * @return result The verification result
     */
    function getVerificationResult(bytes32 proofId) 
        external 
        view 
        returns (VerificationResult memory result);

    /**
     * @dev Get proof data by ID
     * @param proofId The ID of the proof
     * @return proofData The proof data
     */
    function getProofData(bytes32 proofId) 
        external 
        view 
        returns (ProofData memory proofData);

    /**
     * @dev Check if a proof type is supported
     * @param proofType The proof type to check
     * @return supported Whether the proof type is supported
     */
    function isProofTypeSupported(ProofType proofType) external view returns (bool supported);

    /**
     * @dev Get the challenge period for proofs (in seconds)
     * @return challengePeriod The challenge period duration
     */
    function getChallengePeriod() external view returns (uint256 challengePeriod);

    /**
     * @dev Get total number of proofs submitted
     * @return totalProofs Total proof count
     */
    function getTotalProofs() external view returns (uint256 totalProofs);

    /**
     * @dev Get proofs by submitter address
     * @param submitter The address to query
     * @param offset Starting index for pagination
     * @param limit Maximum number of results
     * @return proofIds Array of proof IDs
     */
    function getProofsBySubmitter(
        address submitter, 
        uint256 offset, 
        uint256 limit
    ) external view returns (bytes32[] memory proofIds);
}